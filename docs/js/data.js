window.DOC_DATA={"locales":[{"name":"zh","text":"中文","title":"Apsara","groups":[{"name":"guide","text":"使用指南","docs":[{"content":"# mota\n\nmota 是一个主张「面向对象」的、支持「双向绑定」的 React 状态管理库，它不同于 Redux/flux，\n和 MobX 稍像，但也并不相同且更易用。\n\n## 安装\n\n```sh\nnpm i mota --save\n```\n\n## 示例\n\n### 第一步，定义模型\n\n```js\nexport default class User {\n  firstName = 'jack';\n  lastName = 'hou';\n  get fullName(){\n    reutrn `${this.firstName} ${this.lastName}`;\n  }\n  popup=()=>{\n    alert(this.fullName);\n  }\n}\n```\n\n在 mota 中「模型」是一个或多个「类」，按照你已有的「面向对象」的知识设计你的「业务模型」就行了。\n\n\n### 第二步，关联到组件\n```js\nimport { model } from 'mota';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport User from './user';\n\n@model(User)\nclass App extends React.Component {\n  onFilstNameChange = event=>{\n    this.model.firstName= event.target.value;\n  };\n  render(){\n    return <div>\n      <p>{this.model.fullName}</p>\n      <p>\n        <input onChange={this.onFilstNameChange}/>\n      </p>\n      <p>\n        <button onClick={this.model.popup}></button>\n      </p>\n    </div>;\n  }\n}\nReactDOM.render(<App/>, mountNode);\n```\n\n在「模型」编写完成后，可以通过 `@model` 将某个「类」或某个「类的实例」关联到指定组件，关联后便可以在组件中使用 `this.model` 访问关联的「模型」，mota 会自动「收集组件依赖」，在组件「依赖的属性」发生变化时，自动响应变化并驱动「组件渲染」，请阅读 [模型定义说明](./markdowns/model.md)\n\n\n> 到这里，已经介绍了的 mota 主要用法，你的应用已经基本上有类似使用 mobx 的响应用能力了，但这还不够。\n\n\n### 第三步，双向绑定\n\n不要惊诧，就是「双向绑定」。`mota` 主张「面向对象」，同样也不排斥「双向绑定」，使用 mota 能够实现类似 `ng` 或 `vue` 的绑定效果。还是刚刚的模型，我们来稍微改动一下组件的代码\n\n```js\nimport { model,binding } from 'mota';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport User from './user';\n\n@model(User)\n@binding\nclass App extends React.Component {\n  render(){\n    return <div>\n      <p>{this.model.fullName}</p>\n      <p>\n        <input data-bind=\"name\"/>\n      </p>\n      <p>\n        <button onClick={this.model.popup}></button>\n      </p>\n    </div>;\n  }\n}\nReactDOM.render(<App/>, mountNode);\n```\n\n其中的「关键」就是 `@binding`，使用 `@binding` 后，组件便具备了「双向绑定」的能力，在 `jsx` 中便可以通过名为 `data-bind` 的 `attribute` 进行「绑定表达式」的声明，绑定表达式的 `scope` 是 `model` 而不是 `this`，也就是只能与 `model` 进行绑定。\n\n注意一下，默认情况下，所有的「原生表单组件」，比如 `input`、`textarea`、`select` 都可以直接进行绑定，但是对于一些「组件库」中的「部分表单组件」不能直接绑定，请阅读 [双向绑定说明](./markdowns/binding.md)\n\n## 文档\n- [模型定义说明](./markdowns/model.md)\n- [双向绑定说明](./markdowns/binding.md)\n\n## 其它\n- [版本发布日志](https://github.com/Houfeng/mota/releases)\n- [mota 基于 MIT 协议开源](https://tldrlegal.com/license/mit-license)","group":"guide","name":"readme","title":"快速开始"}]},{"name":"model","text":"模型","docs":[{"content":"# 定义模型\n\n在 mota 中模 model 通常是一个 `class`，如下\n\n```js\nexport default class User {\n  firstName = 'Jack';\n  lastName = 'Hou';\n  get fullName(){\n    reutrn `${this.firstName} ${this.lastName}`;\n  }\n}\n```\n\n也可以是一个 `Object`，如下\n\n```js\nexport default {\n  firstName: 'Jack',\n  lastName: 'Hou',\n  get fullName(){\n    reutrn `${this.firstName} ${this.lastName}`;\n  }\n};\n```\n\n无论哪种形式的 `model` 都能通过 `@model` 关联到组件，使组件具备 `this.model` 这个「可响应」成员，如下\n```js\nimport { model,binding } from 'mota';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport User from './user';\n\n@model(User)\nclass App extends React.Component {\n\n  onChange(field,event){\n    this.model[field] = event.target.value;\n  }\n\n  render(){\n    return <div>\n      <p>{this.model.fullName}</p>\n      <p>\n        <input onChange={this.onChange.bind(this,'firstName')}/>\n        <br/>\n        <input onChange={this.onChange.bind(this,'lastName')}/>\n      </p>\n    </div>;\n  }\n}\n\nReactDOM.render(<App/>, mountNode);\n```\n\n\n值得注意的是，在使用 `@model` 时如果传入的是一个 `class` 最终每个组件实例都会自动创建一个 `新实例`，\n如果需要「单例」，那么需要已经创建好的实例，比如\n\n```js\nclass User{\n  ...\n}\n\nexport default new User();\n```\n\n\n同样，我们关联到组件\n```js\nimport user from './user';\n\n@model(user);\nclass App extends React.Component{\n  ...\n}\n```\n\n或者直接使用 `object` 风格的「模型」","group":"model","name":"model","title":"@model"}]},{"name":"binding","text":"双向绑定","docs":[{"content":"","group":"binding","name":"binding","title":"绑定原生表单组件"}]}]}]};