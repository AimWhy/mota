window.DOC_DATA={"locales":[{"name":"zh","text":"中文","title":"Mota","groups":[{"name":"guide","text":"使用指南","docs":[{"content":"# 快速开始\n\n## 简述\n\nReact 是一个「视图层」的 UI 框架，以常见的 MVC 来讲 React 仅是 View，而我们在编写应用时，通常还需要关注更加重要的 model，对于 React 来讲，我们常常需要一个「状态管理」库。然而，目前大多数针对 React 的状态管理库都需要对其「强依赖」，用其编写的代码并不能轻易在其它地方重用，通过这些框架还具有「排它性」，但是「业务模型」应该是没有过多依赖，应该是无关框架的，它应该随时可以被用在任何合适的 JavaScript 环境中，使用 mota 你可以用原生的普通的 JavaScript 代码编写你的「业务模型」，并让你的「业务模型」轻易在不同框架、不同运行环境下重用。\n\nmota 是一个主张「面向对象」的、支持「双向绑定」的 React 应用辅助库，基于 mota 你可以用纯 JavaScript 为应用编写完全面向对象的「业务模型」，还可以将现有「业务模型」关联到 React 应用中。\n\n## 示例\n\n[在线 TodoList 示例](http://houfeng.net/dn-template-mota/example/)\n([示例源码](https://github.com/Houfeng/dn-template-mota))\n\n## 安装\n\n通过 npm 安装，如下\n```sh\n$ npm i mota --save\n```\n\n或通过 `dawn` 脚手脚加创建工程，如下\n\n```sh\n$ mkdir your_path\n$ cd your_path\n$ dn init -t mota\n$ dn dev\n```\n\n需要先安装 dawn（[参考文档](https://alibaba.github.io/dawn/docs/)）\n\n## 文档\n- [快速开始](http://houfeng.net/mota/#!/zh/guide/quick)\n- [编写业务模型](http://houfeng.net/mota/#!/zh/guide/model)\n- [将组件属性映射到模型](http://houfeng.net/mota/#!/zh/guide/mapping)\n- [自执行函数](http://houfeng.net/mota/#!/zh/guide/autorun)\n- [监听模型变化](http://houfeng.net/mota/#!/zh/guide/watch)\n- [将模型数据与表单绑定](http://houfeng.net/mota/#!/zh/guide/binding)\n\n## 链接\n- [版本发布日志](https://github.com/Houfeng/mota/releases)\n- [MIT 开源协议](https://tldrlegal.com/license/mit-license)","group":"guide","name":"quick","title":"快速开始","index":1},{"content":"# 编写业务模型\n\n在 mota 中「模型」如同其它 OOP 语言中的已有的「面向对象」的知识几首一模一样，是由一个或多个 `class` 或普通的的 `Object` 组成的。\n\n如下示例通过编写一个名为 `User` 的 `class`，创建了一个「用户模型」\n```js\nexport default class User {\n  firstName = 'Jack';\n  lastName = 'Hou';\n  get fullName(){\n    reutrn `${this.firstName} ${this.lastName}`;\n  }\n}\n```\n\n也可以是一个 `Object`，通过这个模型需要是「单例」时，可采用这种方式，如下\n\n```js\nexport default {\n  firstName: 'Jack',\n  lastName: 'Hou',\n  get fullName(){\n    reutrn `${this.firstName} ${this.lastName}`;\n  }\n};\n```\n\n在「业务模型」编写完成后，可以通过 `@model` 将某个「类」或某个「类的实例」关联到指定组件，关联后便可以在组件中使用 `this.model` 访问关联的「模型」，mota 会自动「收集组件依赖」，在组件「依赖的属性」发生变化时，自动响应变化并驱动「组件渲染」，如下\n\n```js\nimport { model,binding } from 'mota';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport User from './user';\n\n@model(User)\nclass App extends React.Component {\n\n  onChange(field,event){\n    this.model[field] = event.target.value;\n  }\n\n  render(){\n    return <div>\n      <p>{this.model.fullName}</p>\n      <p>\n        <input onChange={this.onChange.bind(this,'firstName')}/>\n        <br/>\n        <input onChange={this.onChange.bind(this,'lastName')}/>\n      </p>\n    </div>;\n  }\n}\n\nReactDOM.render(<App/>, mountNode);\n```\n\n值得注意的是，在使用 `@model` 时如果传入的是一个 `class` 最终每个组件实例都会自动创建一个 `新实例`。","group":"guide","name":"model","title":"编写业务模型","index":2},{"content":"# 属性映射\n\n当你基于 `model` 编程时，你的「视图层」就会更干净，只关注「显示」相关的问题，在 React 中通常会将应用折分为多个组件重用它们，并在用时传递给它「属性」，mota 提供了将组件属性「映射到 model」的能力，如下\n\n```js\n@model({ value: 'demo' })\n@mapping(['value'])\nclass Demo extends React.Component {\n  render () {\n    return <div>{this.model.value}</div>;\n  }\n}\n```\n\n上边的代码通过 `mapping` 将，`Demo` 这个组件的 `value` 这个属性映射到了 `model.value`，在属性 `value` 发生变化时，会自动同步到 `model.value` 中。\n\n组件属性的模型中的成员变量，还可以不同名，通过一个 map 即可完成，如下:\n\n```js\n@model({ value: 'demo' })\n@mapping({ content: 'value' })\nclass Demo extends React.Component {\n  render () {\n    return <div>{this.model.value}</div>;\n  }\n}\n```\n\n如上边的代码，即可将组件 demo 的 `content` 属性映射到了 `model.value` 上了。","group":"guide","name":"mapping","title":"属性映射","index":3},{"content":"# 自执行函数\n\nmota 中提供了一个 `autorun` 函数，可用于装饰 React 组件的成员方法，被装饰的「成员方法」将会在组件挂载后自动执行一次，mota 将「收集成函数中对模型数据的依赖」，在依赖数据发生变化时会「重新自动执行」对应的组件方法。\n\n示例\n\n```js\nimport { Component } from 'react';\nimport { model, autorun } from 'mota';\nimport DemoModel from './models/demo';\n\n@model(DemoModel)\nexport default Demo extends Component {\n\n  @autorun\n  test() {\n    console.log(this.model.name);\n  }\n\n}\n```\n\n上边的示例组件在被挂载后，将会自动执行 `test` 方法，同时 mota 会发现函数依赖了 `model.name`，那么，在 `model.name` 发生变化时，就会重新搪行 `test` 方法。","group":"guide","name":"autorun","title":"自执行函数","index":4},{"content":"# 监听模型变化\n\n\nmota 中提供了一个 `watch` 函数，可用于装饰 React 组件的成员方法，`watch` 可以指定要要监听的「模型数据」，在模型数据发变化时，就会自动执行「被装饰的函数」，`watch` 还可以像 `autorun` 一样，声明自动执行一次，但不 `autorun` 还是不尽相同，主要有如下区别\n\n- `autorun` 会自动收集依赖，而 `watch` 不会关心组件方法中有何依赖，需要手动指定依赖的模型数据\n- `watch` 默认不会「自动执行」，需显式的指定立即执行参数，才会自动执行首次。\n- `autorun` 依赖的是「模型数据」本身，而 `watch` 依赖的是每次的「计算结果」\n \n示例\n\n```js\nimport { Component } from 'react';\nimport { model, autorun } from 'mota';\nimport DemoModel from './models/demo';\n\n@model(DemoModel)\nexport default Demo extends Component {\n\n  @watch(model=>model.name)\n  test() {\n    console.log('name 发生变化');\n  }\n\n}\n```\n\n上边的代码，通过 watch 装饰了 `test` 方法，并指定了监听的模型数据 `model.name`，那么每当 `model.name` 发生变\b化，都会打印 `name 发生变化`.\n\n`watch` 是取重新执行，取决于 `watch` 的首个参数（通常是一个匿名函数）的计算结果，每当依赖的模型数据发生变化，`watch` 都会重新计算，当计算结果有变化时，才会执行被装饰的「组件方法」，示例\n\n```js\nexport default Demo extends Component {\n\n  @watch(model=>model.name+model.age)\n  test() {\n    console.log('name 发生变化');\n  }\n\n}\n```\n\n有时，我们希望 `watch` 也能自动执行首次，那么可通过向第二个参数传一个 `true` 声明其自动执行\n\n```js\nexport default Demo extends Component {\n\n  @watch(model=>model.name,true)\n  test() {\n    console.log('name 发生变化');\n  }\n\n}\n```\n\n上边的 `test` 方法，将会在「组件挂载之后自动执行」，之后在 `model.name` 发生变化时也将自动执行。","group":"guide","name":"watch","title":"监听模型变化","index":5},{"content":"# 数据绑定\n\n不要惊诧，就是「双向绑定」。`mota` 主张「面向对象」，同样也不排斥「双向绑定」，使用 mota 能够实现类似 `ng` 或 `vue` 的绑定效果。还是刚刚的模型，我们来稍微改动一下组件的代码\n\n```js\nimport { model,binding } from 'mota';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport User from './user';\n\n@model(User)\n@binding\nclass App extends React.Component {\n  render(){\n    const { fullName, firstName, popup } = this.model;\n    return <div>\n      <p>{fullName}</p>\n      <p>\n        <input data-bind=\"firstName\"/>\n        <button onClick={popup}> click me </button>\n      </p>\n    </div>;\n  }\n}\nReactDOM.render(<App/>, mountNode);\n```\n\n其中的「关键」就是 `@binding`，使用 `@binding` 后，组件便具备了「双向绑定」的能力，在 `jsx` 中便可以通过名为 `data-bind` 的 `attribute` 进行「绑定表达式」的声明，绑定表达式的 `scope` 是 `model` 而不是 `this`，也就是只能与 `model` 进行绑定。\n\n\n注意一下，默认情况下，所有的「原生表单组件」，比如 `input`、`textarea`、`select` 都可以直接进行绑定，但是对于一些「组件库」中的「部分表单组件」不能直接绑定。","group":"guide","name":"binding","title":"数据绑定","index":6}]}],"links":[{"text":"文档","url":"//houfeng.net/mota/"},{"text":"GitHub","url":"//github.com/Houfeng/mota"},{"text":"示例","url":"//houfeng.net/dn-template-mota/example/"}]}]};