window.DOC_DATA={"locales":[{"name":"zh","text":"中文 (CN)","title":"Mota","groups":[{"name":"guide","text":"使用指南","docs":[{"group":"guide","name":"quick","title":"快速开始","index":1,"source":"# 快速开始\n\n## 简述\n\nReact 是一个「视图层」的 UI 框架，以常见的 MVC 来讲 React 仅是 View，而我们在编写应用时，通常还需要关注更加重要的 model，对于 React 来讲，我们常常需要一个「状态管理」库。然而，目前大多数针对 React 的状态管理库都是「强依赖」过多的侵入本应该独立的业务模型中，导致「业务逻辑」对应的代码并不能轻易在其它地方重用，往往这些框架还具有「强排它性」，但是「业务模型」应该是没有过多依赖，应该是无关框架的，它应该随时可以被用在任何合适的 JavaScript 环境中，使用 mota 你可以用原生的普通的 JavaScript 代码编写你的「业务模型」，并让你的「业务模型」在不同框架、不同运行环境下重用更为容易。\n\nMota 是一个响应式的 React 应用状态管理库，基于 Mota 你可以用单纯无依赖的 JavaScript 为应用编写「业务模型」，并轻易的将「业务模型」关联到 React 应用中。\n\n## 示例\n\n[在线 TodoList 示例](http://houfeng.net/dn-template-mota/example/)\n([示例源码](https://github.com/Houfeng/dn-template-mota))\n\n## 安装\n\n通过 npm 安装，如下\n```sh\n$ npm i mota --save \n```\n\n或通过 `dawn` 脚手脚加创建工程，如下\n\n```sh\n$ mkdir your_path\n$ cd your_path\n$ dn init -t mota\n$ dn dev\n```\n\n需要先安装 dawn（[Dawn 安装及使用文档](https://alibaba.github.io/dawn/docs/)）\n\n## 结构\n\n一个 `mota` 工程的通常结构如下\n\n```sh\n.\n├── README.md\n├── package.json\n└── src\n    ├── assets\n    │   ├── common.less\n    │   ├── favicon.ico\n    │   └── index.html\n    ├── components\n    │   ├── todoApp.js\n    │   └── todoItem.js\n    ├── index.js\n    └── models\n        ├── TodoItem.js\n        ├── TodoList.js\n        └── index.js\n```\n\n## 文档\n- [快速开始](http://houfeng.net/mota/#!/zh/guide/quick)\n- [编写业务模型](http://houfeng.net/mota/#!/zh/guide/model)\n- [将组件属性映射到模型](http://houfeng.net/mota/#!/zh/guide/mapping)\n- [自执行函数](http://houfeng.net/mota/#!/zh/guide/autorun)\n- [监听模型变化](http://houfeng.net/mota/#!/zh/guide/watch)\n- [将模型数据与表单绑定](http://houfeng.net/mota/#!/zh/guide/binding)\n\n## 链接\n- [版本发布日志](https://github.com/Houfeng/mota/releases)\n- [MIT 开源协议](https://tldrlegal.com/license/mit-license)","filename":"markdowns/quick.md","root":"/Users/Houfeng/my/dev/mota","result":"<h1 id=\"%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B\">快速开始</h1>\n<h2 id=\"%E7%AE%80%E8%BF%B0\">简述</h2>\n<p>React 是一个「视图层」的 UI 框架，以常见的 MVC 来讲 React 仅是 View，而我们在编写应用时，通常还需要关注更加重要的 model，对于 React 来讲，我们常常需要一个「状态管理」库。然而，目前大多数针对 React 的状态管理库都是「强依赖」过多的侵入本应该独立的业务模型中，导致「业务逻辑」对应的代码并不能轻易在其它地方重用，往往这些框架还具有「强排它性」，但是「业务模型」应该是没有过多依赖，应该是无关框架的，它应该随时可以被用在任何合适的 JavaScript 环境中，使用 mota 你可以用原生的普通的 JavaScript 代码编写你的「业务模型」，并让你的「业务模型」在不同框架、不同运行环境下重用更为容易。</p>\n<p>Mota 是一个响应式的 React 应用状态管理库，基于 Mota 你可以用单纯无依赖的 JavaScript 为应用编写「业务模型」，并轻易的将「业务模型」关联到 React 应用中。</p>\n<h2 id=\"%E7%A4%BA%E4%BE%8B\">示例</h2>\n<p><a href=\"http://houfeng.net/dn-template-mota/example/\">在线 TodoList 示例</a>\n(<a href=\"https://github.com/Houfeng/dn-template-mota\">示例源码</a>)</p>\n<h2 id=\"%E5%AE%89%E8%A3%85\">安装</h2>\n<p>通过 npm 安装，如下</p>\n<pre><code class=\"language-sh\">$ npm i mota --save \n</code></pre>\n<p>或通过 <code>dawn</code> 脚手脚加创建工程，如下</p>\n<pre><code class=\"language-sh\">$ mkdir your_path\n$ cd your_path\n$ dn init -t mota\n$ dn dev\n</code></pre>\n<p>需要先安装 dawn（<a href=\"https://alibaba.github.io/dawn/docs/\">Dawn 安装及使用文档</a>）</p>\n<h2 id=\"%E7%BB%93%E6%9E%84\">结构</h2>\n<p>一个 <code>mota</code> 工程的通常结构如下</p>\n<pre><code class=\"language-sh\">.\n├── README.md\n├── package.json\n└── src\n    ├── assets\n    │   ├── common.less\n    │   ├── favicon.ico\n    │   └── index.html\n    ├── components\n    │   ├── todoApp.js\n    │   └── todoItem.js\n    ├── index.js\n    └── models\n        ├── TodoItem.js\n        ├── TodoList.js\n        └── index.js\n</code></pre>\n<h2 id=\"%E6%96%87%E6%A1%A3\">文档</h2>\n<ul>\n<li><a href=\"http://houfeng.net/mota/#!/zh/guide/quick\">快速开始</a></li>\n<li><a href=\"http://houfeng.net/mota/#!/zh/guide/model\">编写业务模型</a></li>\n<li><a href=\"http://houfeng.net/mota/#!/zh/guide/mapping\">将组件属性映射到模型</a></li>\n<li><a href=\"http://houfeng.net/mota/#!/zh/guide/autorun\">自执行函数</a></li>\n<li><a href=\"http://houfeng.net/mota/#!/zh/guide/watch\">监听模型变化</a></li>\n<li><a href=\"http://houfeng.net/mota/#!/zh/guide/binding\">将模型数据与表单绑定</a></li>\n</ul>\n<h2 id=\"%E9%93%BE%E6%8E%A5\">链接</h2>\n<ul>\n<li><a href=\"https://github.com/Houfeng/mota/releases\">版本发布日志</a></li>\n<li><a href=\"https://tldrlegal.com/license/mit-license\">MIT 开源协议</a></li>\n</ul>\n"},{"group":"guide","name":"model","title":"编写业务模型","index":2,"source":"# 编写业务模型\n\n在你编写模型之前，先放下 React 也放下 Mota，就用单纯的 JavaScript 去编写你的业务模型，或有一个或多个类、或就是几个 Object，依它们应有的、自然的关系去抽像就行了，业务模型不依赖于 UI、也不依赖于某个框架，它易于测试，你可以针对它做单元测试。它易于重用，你可以将它用在合适的地方。最后， Mota 只是出场把它关联到 React。\n\n在 Mota 中「模型」可以是由一个 `class` 或普通的的 `Object`，整个「业务模型层」会由多个 `class` 和多个 `Object` 组成，而编写模型所需要的知识就是 JavaScript 固有的编程的知识。\n\n如下示例通过编写一个名为 `User` 的 `class` 创建了一个「用户模型」\n\n```js\nexport default class User {\n  firstName = 'Jack';\n  lastName = 'Hou';\n  get fullName(){\n    reutrn `${this.firstName} ${this.lastName}`;\n  }\n}\n```\n\n也可以是一个 `Object`，通常这个模型需要是「单例」时，可采用这种方式，如下\n\n```js\nexport default {\n  firstName: 'Jack',\n  lastName: 'Hou',\n  get fullName(){\n    reutrn `${this.firstName} ${this.lastName}`;\n  }\n};\n```\n\n在「业务模型」编写完成后，可以通过 `@model` 将某个「类」或「类的实例」关联到指定组件，关联后便可以在组件中使用 `this.model` 访问「模型的成员变量或方法」了，Mota 还会自动「收集组件依赖」，在组件「依赖的模型数据」发生变化时，自动响应变化并「驱动组件重新渲染」，如下\n\n```js\nimport { model,binding } from 'mota';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport User from './models/user';\n\n@model(User)\nclass App extends React.Component {\n\n  onChange(field,event){\n    this.model[field] = event.target.value;\n  }\n\n  render(){\n    return <div>\n      <p>{this.model.fullName}</p>\n      <p>\n        <input onChange={this.onChange.bind(this,'firstName')}/>\n        <br/>\n        <input onChange={this.onChange.bind(this,'lastName')}/>\n      </p>\n    </div>;\n  }\n}\n\nReactDOM.render(<App/>, mountNode);\n```\n\n值得注意的是，在使用 `@model` 时如果传入的是一个 `class` 最终每个组件实例都会自动创建一个 `独立的实例`，这样带来的好处是「当一个页面中有同一个组件的多个实例时，不会相互影响」。","filename":"markdowns/model.md","root":"/Users/Houfeng/my/dev/mota","result":"<h1 id=\"%E7%BC%96%E5%86%99%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9E%8B\">编写业务模型</h1>\n<p>在你编写模型之前，先放下 React 也放下 Mota，就用单纯的 JavaScript 去编写你的业务模型，或有一个或多个类、或就是几个 Object，依它们应有的、自然的关系去抽像就行了，业务模型不依赖于 UI、也不依赖于某个框架，它易于测试，你可以针对它做单元测试。它易于重用，你可以将它用在合适的地方。最后， Mota 只是出场把它关联到 React。</p>\n<p>在 Mota 中「模型」可以是由一个 <code>class</code> 或普通的的 <code>Object</code>，整个「业务模型层」会由多个 <code>class</code> 和多个 <code>Object</code> 组成，而编写模型所需要的知识就是 JavaScript 固有的编程的知识。</p>\n<p>如下示例通过编写一个名为 <code>User</code> 的 <code>class</code> 创建了一个「用户模型」</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n  firstName <span class=\"token operator\">=</span> <span class=\"token string\">'Jack'</span><span class=\"token punctuation\">;</span>\n  lastName <span class=\"token operator\">=</span> <span class=\"token string\">'Hou'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">fullName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    reutrn <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>也可以是一个 <code>Object</code>，通常这个模型需要是「单例」时，可采用这种方式，如下</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  firstName<span class=\"token punctuation\">:</span> <span class=\"token string\">'Jack'</span><span class=\"token punctuation\">,</span>\n  lastName<span class=\"token punctuation\">:</span> <span class=\"token string\">'Hou'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">fullName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    reutrn <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>在「业务模型」编写完成后，可以通过 <code>@model</code> 将某个「类」或「类的实例」关联到指定组件，关联后便可以在组件中使用 <code>this.model</code> 访问「模型的成员变量或方法」了，Mota 还会自动「收集组件依赖」，在组件「依赖的模型数据」发生变化时，自动响应变化并「驱动组件重新渲染」，如下</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> model<span class=\"token punctuation\">,</span>binding <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'mota'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> User <span class=\"token keyword\">from</span> <span class=\"token string\">'./models/user'</span><span class=\"token punctuation\">;</span>\n\n@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span>User<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token function\">onChange</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">field<span class=\"token punctuation\">,</span>event</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">[</span>field<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">.</span>fullName<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>input onChange<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">onChange</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span><span class=\"token string\">'firstName'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>br<span class=\"token operator\">/</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>input onChange<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">onChange</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span><span class=\"token string\">'lastName'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App<span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> mountNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>值得注意的是，在使用 <code>@model</code> 时如果传入的是一个 <code>class</code> 最终每个组件实例都会自动创建一个 <code>独立的实例</code>，这样带来的好处是「当一个页面中有同一个组件的多个实例时，不会相互影响」。</p>\n"},{"group":"guide","name":"mapping","title":"属性映射","index":3,"source":"# 属性映射\n\n在 React 中通常会将应用折分为多个组件重用它们，并在用时传递给它「属性」，Mota 提供了将「组件属性」映射到「模型数据」的能力，基于 `model` 编程会让「视图层」的编写更为方例，专注于 UI 的呈现，如下\n\n```js\n@model({ value: 'demo' })\n@mapping(['value'])\nclass Demo extends React.Component {\n  render () {\n    return <div>{this.model.value}</div>;\n  }\n}\n```\n\n上边的代码通过 `mapping` 将 `Demo` 这个组件的 `value` 属性映射到了 `model.value` 上，在组件的属性 `value` 发生变化时，会自动同步到 `model.value` 中。\n\n通过一个 `map` 进行映射，还可以让「组件属性」和「模型的成员」使用不同名称，如下:\n\n```js\n@model({ value: 'demo' })\n@mapping({ content: 'value' })\nclass Demo extends React.Component {\n  render () {\n    return <div>{this.model.value}</div>;\n  }\n}\n```\n\n上边的代码，将组件 demo 的 `content` 属性映射到了 `model.value` 上，那么这个组件就可以这样使用了\n\n```js\nfunction App(){\n  return <Demo content={'yyyy'} />;\n}\n```\n\n`Demo` 组件的 `content` 属性，将自动被赋值给 `model.value`，如果没有 `mapping`，通常我们就需要在 `componentDidMount` 和 `componentWillReceiveProps` 之类的生命周函数去处理。其实，`mapping` 就像是一个语法糖，使用它将不再需要手动处理 prop->model 的更新了。","filename":"markdowns/mapping.md","root":"/Users/Houfeng/my/dev/mota","result":"<h1 id=\"%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84\">属性映射</h1>\n<p>在 React 中通常会将应用折分为多个组件重用它们，并在用时传递给它「属性」，Mota 提供了将「组件属性」映射到「模型数据」的能力，基于 <code>model</code> 编程会让「视图层」的编写更为方例，专注于 UI 的呈现，如下</p>\n<pre><code class=\"language-js\">@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token string\">'demo'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n@<span class=\"token function\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'value'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上边的代码通过 <code>mapping</code> 将 <code>Demo</code> 这个组件的 <code>value</code> 属性映射到了 <code>model.value</code> 上，在组件的属性 <code>value</code> 发生变化时，会自动同步到 <code>model.value</code> 中。</p>\n<p>通过一个 <code>map</code> 进行映射，还可以让「组件属性」和「模型的成员」使用不同名称，如下:</p>\n<pre><code class=\"language-js\">@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> <span class=\"token string\">'demo'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n@<span class=\"token function\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> content<span class=\"token punctuation\">:</span> <span class=\"token string\">'value'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上边的代码，将组件 demo 的 <code>content</code> 属性映射到了 <code>model.value</code> 上，那么这个组件就可以这样使用了</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>Demo content<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token string\">'yyyy'</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><code>Demo</code> 组件的 <code>content</code> 属性，将自动被赋值给 <code>model.value</code>，如果没有 <code>mapping</code>，通常我们就需要在 <code>componentDidMount</code> 和 <code>componentWillReceiveProps</code> 之类的生命周函数去处理。其实，<code>mapping</code> 就像是一个语法糖，使用它将不再需要手动处理 prop-&gt;model 的更新了。</p>\n"},{"group":"guide","name":"autorun","title":"自执行函数","index":4,"source":"# 自执行函数\n\nMota 中提供了一个 `autorun` 函数，可用于装饰 React 组件的成员方法，被装饰的「成员方法」将会在组件挂载后自动执行一次，Mota 将「收集方法中依赖的模型数据」，在依赖的模型数据发生变化时会「自动重新执行」对应的组件方法。\n\n示例\n\n```js\nimport { Component } from 'react';\nimport { model, autorun } from 'mota';\nimport DemoModel from './models/demo';\n\n@model(DemoModel)\nexport default Demo extends Component {\n\n  @autorun\n  test() {\n    console.log(this.model.name);\n  }\n\n}\n```\n\n上边的示例代码中，组件在被挂载后将会自动执行 `test` 方法，同时 mota 会发现方法中依赖了 `model.name`，那么，在 `model.name` 发生变化时，就会重新执行 `test` 方法。","filename":"markdowns/autorun.md","root":"/Users/Houfeng/my/dev/mota","result":"<h1 id=\"%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0\">自执行函数</h1>\n<p>Mota 中提供了一个 <code>autorun</code> 函数，可用于装饰 React 组件的成员方法，被装饰的「成员方法」将会在组件挂载后自动执行一次，Mota 将「收集方法中依赖的模型数据」，在依赖的模型数据发生变化时会「自动重新执行」对应的组件方法。</p>\n<p>示例</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> model<span class=\"token punctuation\">,</span> autorun <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'mota'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> DemoModel <span class=\"token keyword\">from</span> <span class=\"token string\">'./models/demo'</span><span class=\"token punctuation\">;</span>\n\n@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span>DemoModel<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Demo <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n\n  @autorun\n  <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上边的示例代码中，组件在被挂载后将会自动执行 <code>test</code> 方法，同时 mota 会发现方法中依赖了 <code>model.name</code>，那么，在 <code>model.name</code> 发生变化时，就会重新执行 <code>test</code> 方法。</p>\n"},{"group":"guide","name":"watch","title":"监听模型变化","index":5,"source":"# 监听模型变化\n\n\nMota 中提供了一个 `watch` 函数，可用于装饰 React 组件的成员方法，`watch` 可以指定要观察的「模型数据」，在模型数据发变化时，就会自动执行「被装饰的组件方法」，`watch` 还可以像 `autorun` 一样自动执行一次，但它和 `autorun` 还是不尽相同，主要有如下区别\n\n- `autorun` 会自动收集依赖，而 `watch` 不会关心组件方法中有何依赖，需要手动指定依赖的模型数据\n- `watch` 默认不会「自动执行」，需显式的指定「立即执行参数为 true」，才会自动执行首次。\n- `autorun` 依赖的是「模型数据」本身，而 `watch` 依赖的是「计算函数」每次的「计算结果」\n \n示例\n\n```js\nimport { Component } from 'react';\nimport { model, autorun } from 'mota';\nimport DemoModel from './models/demo';\n\n@model(DemoModel)\nexport default Demo extends Component {\n\n  @watch(model=>model.name)\n  test() {\n    console.log('name 发生了变化');\n  }\n\n}\n```\n\n上边的代码，通过 `watch` 装饰了 `test` 方法，并指定了观察的模型数据 `model.name`，那么每当 `model.name` 发生变\b化时，都会打印 `name 发生了变化`.\n\n`watch` 是否重新执行，取决于 `watch` 的作为第一个参数传给它的「计算函数」的计算结果，每当依赖的模型数据发生变化时 `watch` 都会重执行计算函数，当计算结果有变化时，才会执行被装饰的「组件方法」，示例\n\n```js\nexport default Demo extends Component {\n\n  @watch(model=>model.name+model.age)\n  test() {\n    console.log('name 发生变化');\n  }\n\n}\n```\n\n有时，我们希望 `watch` 能首先自动执行一次，那么可通过向第二个参数传一个 `true` 声明这个 `watch` 要自动执行一次。\n\n```js\nexport default Demo extends Component {\n\n  @watch(model=>model.name,true)\n  test() {\n    console.log('name 发生变化');\n  }\n\n}\n```\n\n上边的 `test` 方法，将会在「组件挂载之后自动执行」，之后在 `model.name` 发生变化时也将自动重新执行。","filename":"markdowns/watch.md","root":"/Users/Houfeng/my/dev/mota","result":"<h1 id=\"%E7%9B%91%E5%90%AC%E6%A8%A1%E5%9E%8B%E5%8F%98%E5%8C%96\">监听模型变化</h1>\n<p>Mota 中提供了一个 <code>watch</code> 函数，可用于装饰 React 组件的成员方法，<code>watch</code> 可以指定要观察的「模型数据」，在模型数据发变化时，就会自动执行「被装饰的组件方法」，<code>watch</code> 还可以像 <code>autorun</code> 一样自动执行一次，但它和 <code>autorun</code> 还是不尽相同，主要有如下区别</p>\n<ul>\n<li><code>autorun</code> 会自动收集依赖，而 <code>watch</code> 不会关心组件方法中有何依赖，需要手动指定依赖的模型数据</li>\n<li><code>watch</code> 默认不会「自动执行」，需显式的指定「立即执行参数为 true」，才会自动执行首次。</li>\n<li><code>autorun</code> 依赖的是「模型数据」本身，而 <code>watch</code> 依赖的是「计算函数」每次的「计算结果」</li>\n</ul>\n<p>示例</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> model<span class=\"token punctuation\">,</span> autorun <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'mota'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> DemoModel <span class=\"token keyword\">from</span> <span class=\"token string\">'./models/demo'</span><span class=\"token punctuation\">;</span>\n\n@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span>DemoModel<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Demo <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n\n  @<span class=\"token function\">watch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">model</span><span class=\"token operator\">=></span>model<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name 发生了变化'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上边的代码，通过 <code>watch</code> 装饰了 <code>test</code> 方法，并指定了观察的模型数据 <code>model.name</code>，那么每当 <code>model.name</code> 发生变\b化时，都会打印 <code>name 发生了变化</code>.</p>\n<p><code>watch</code> 是否重新执行，取决于 <code>watch</code> 的作为第一个参数传给它的「计算函数」的计算结果，每当依赖的模型数据发生变化时 <code>watch</code> 都会重执行计算函数，当计算结果有变化时，才会执行被装饰的「组件方法」，示例</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Demo <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n\n  @<span class=\"token function\">watch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">model</span><span class=\"token operator\">=></span>model<span class=\"token punctuation\">.</span>name<span class=\"token operator\">+</span>model<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span>\n  <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name 发生变化'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>有时，我们希望 <code>watch</code> 能首先自动执行一次，那么可通过向第二个参数传一个 <code>true</code> 声明这个 <code>watch</code> 要自动执行一次。</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Demo <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n\n  @<span class=\"token function\">watch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">model</span><span class=\"token operator\">=></span>model<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name 发生变化'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上边的 <code>test</code> 方法，将会在「组件挂载之后自动执行」，之后在 <code>model.name</code> 发生变化时也将自动重新执行。</p>\n"},{"group":"guide","name":"binding","title":"数据绑定","index":6,"source":"# 数据绑定\n\n\n### 基本用法\n\n不要惊诧，就是「双向绑定」。Mota 不排斥「双向绑定」，使用 Mota 能够实现类似 `ng` 或 `vue` 的绑定效果。还是前边小节中的模型，我们来稍微改动一下组件的代码\n\n```js\nimport { model,binding } from 'mota';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport User from './models/user';\n\n@model(User)\n@binding\nclass App extends React.Component {\n  render(){\n    const { fullName, firstName, popup } = this.model;\n    return <div>\n      <p>{fullName}</p>\n      <p>\n        <input data-bind=\"firstName\"/>\n        <button onClick={popup}> click me </button>\n      </p>\n    </div>;\n  }\n}\nReactDOM.render(<App/>, mountNode);\n```\n\n~~其中的「关键」就是 `@binding`，使用 `@binding` 后~~ (>=1.2.0 的版本将会自动处理，不必显示的启用)，组件便具备了「双向绑定」的能力，在 `jsx` 中便可以通过名为 `data-bind` 的自定义 `attribute` 进行绑定了，`data-bind` 的值是一个「绑定表达式字符串」，绑定表达式执行的 `scope` 是 `model` 而不是 `this`，也就是只能与 `模型的成员` 进行绑定。\n\n会有一种情况是当要绑定的数据是一个循环变量时，「绑定表达式」写起会较麻烦也稍显长，比如\n\n```js\n@model(userModel)\n@binding\nclass App extends React.Component {\n  render(){\n    const { userList } = this.model;\n    return <ul>\n     {userList.map((user,index)=>(\n       <li key={user.id}>\n         <input type=\"checkobx\" data-bind={`userList[${index}].selected`}>\n         {user.name}\n       </li>\n     ))}\n    </ul>;\n  }\n}\n```\n\n因为「绑定表达式」的执行 `scope` 默认是 `this.model`，以及「表达式是个字符串」，看一下 `userList[${index}].selected` 这并不友好，为此 Mota 还提供了一个名为 `data-scope` 的 `attribute`，通过它能改变要绑定的 `scope`，参考如下示例\n\n```js\n@model(userModel)\n@binding\nclass App extends React.Component {\n  render(){\n    const { userList } = this.model;\n    return <ul>\n     {userList.map(user=>(\n       <li key={user.id}>\n         <input type=\"checkobx\" data-scope={user} data-bind=\"selected\">\n         {user.name}\n       </li>\n     ))}\n    </ul>;\n  }\n}\n```\n\n通过 `data-scope` 将 `input` 的绑定上下文对象声明为当前循环变量 `user`，这样就可以用 `data-bind` 直接绑定到对应 `user` 的属性上了。\n\n### 原生表单控件\n\n所有的原生表单控件，比如「普通 input、checkbox、radio、textarea、select」都可以直接进行绑定。其中，「普通 input 和 textrea」比较简单，将一个字符类型的模型数据与控件绑定就行了，而对于「checkbox 和 radio」 有多种不同的绑定形式。\n\n将「checkbox 或 radio」绑定到一个 `boolean` 值，此时会将 checkbox 或 radio 的 `checked` 属性和模型数据建立绑定，`checked` 反应了 `boolean` 变量的值，参考如下示例\n\n```js\n@model({ selected:false })\n@binding\nclass App extends React.Component {\n  render(){\n    return <div>\n      <input type=\"checkbox\" data-bind=\"selected\"/>\n      <input type=\"radio\" data-bind=\"selected\"/>\n    </div>;\n  }\n}\n```\n\n如上示例通过 `this.model.selected` 就能拿到当前 checkbox 或 radio 的选中状态。\n\n\n将 checkbox 绑定到一个「数组」，通常是多个 checkbox 绑定同一个数组变量上，此时和数据建立绑定的是 checkbox 的 value，数据中会包含当前选中的 checkbox 的 value，如下\n\n```js\n@model({ selected:[] })\n@binding\nclass App extends React.Component {\n  render(){\n    return <div>\n      <input type=\"checkbox\" data-bind=\"selected\" value=\"1\"/>\n      <input type=\"checkbox\" data-bind=\"selected\" value=\"2\"/>\n    </div>;\n  }\n}\n```\n\n如上示例，通过 `this.selected` 就能知道当前有哪些 checkbox 被选中了，并拿到所有选中的 value\n\n\n将多个 radio 绑定我到一个「字符类型的变量」，此时和数据建立绑定的是 raido 的 value，因为 radio 是单选的，所以对应的数据是当前选中的 radio 的 value，如下\n\n```js\n@model({ selected:'' })\n@binding\nclass App extends React.Component {\n  render(){\n    return <div>\n      <input type=\"radio\" data-bind=\"selected\" value=\"1\"/>\n      <input type=\"radio\" data-bind=\"selected\" value=\"2\"/>\n    </div>;\n  }\n}\n```\n通过 `this.model.selected` 就能拿到当前选中的 radio 的 `value`\n\n\n### 自定义组件\n\n但是对于一些「组件库」中的「部分表单组件」不能直接绑定，因为 Mota 并没有什么依据可以判断这是一个什么组件。所以 Mota 提供了一个名为 `bindable` 的函数，用将任意组件包装成「可绑定组件」。\n\nbindable 有两种个参数，用于分别指定「原始组件」和「包装选项」\n\n```js\n//可以这样\nconst MyComponent = bindable(opts, Component);\n//也可这样\nconst MyCompoent = bindable(Component, opts);\n```\n\n关建是 `bindable` 需要的 `opts`，通过 `opts` 我们可以造诉 Mota 如何绑定这个组件，`opts` 中有两个重要的成员，它的结构如下\n\n```js\n{\n  value: ['value 对应的属性名'],\n  event: ['value 改变的事件名']\n}\n```\n\n所以，我们可以这样包装一个自定义文本输入框\n\n```js\nconst MyInput = bindable(Input,{\n  value: ['value'],\n  event: ['onChange']\n});\n```\n\n对这种「value 不需要转换，`change` 能通过 `event` 或 `event.target.value` 拿到值」的组件，通过如上的代码就能完成包装了。\n\n对于有 `onChange` 和 `value` 的这类文本输入组件，因为 opts 的默认值就是\n\n```js\n{\n  value: ['value'],\n  event: ['onChange']\n}\n```\n\n所以，可以更简单，这样就行，\n```js\nconst MyInput = bindable(Input);\n```\n\n而对于 checkbox 和 radio 来讲，如上边讲到的它「根据不同的数据型有不同的绑定形式」，这就需要指定处理函数了，如下\n\n```js\nconst radioOpts = {\n  prop: ['checked', (ctx, props) => {\n    const mValue = ctx.getValue();\n    if (typeof mValue == 'boolean') {\n      return !!mValue;\n    } else {\n      return mValue == props.value;\n    }\n  }],\n  event: ['onChange', (ctx, event) => {\n    const { value, checked } = event.target;\n    const mValue = ctx.getValue();\n    if (typeof mValue == 'boolean') {\n      ctx.setValue(checked);\n    } else if (checked) ctx.setValue(value);\n  }]\n};\n```\n\n通过 `prop` 的第二个值，能指定「属性处理函数」，`event` 的第二个值能指取「事件处理函数」，处理函数的 `ctx` 是个特殊的对象 \n\n- `ctx.getValue` 能获取「当前绑定的模型数据」\n- `ctx.setValue` 能设置「当前绑定的模型数据」\n\n上边是 `radio` 的配置，首先，在「属性处理函数」中通过绑定的「模型数据的类型」决定 `checked` 最终的状态是什么，并在函数中返回。再次，在「事件处理函数」中通过绑定的「模型数据的类型」决定将什么值回写到模型中。\n\n通过「属性处理函数」和「事件处理函数」几乎就能将任意的自定义组件转换为「可绑定组件」了。\n\n另外，对于常见的 `CheckBox` 和 `Radio` 类型的组件 Mota 也提供了内建的 `opts` 配置支持，如果一个自定义组件拥有和「原生 checkbox 一致的属性和事件模型」，那边可以直接用简单的方式去包装，如下\n\n```js\nconst MyCheckBox = bindable('checkbox',CheckBox);\nconst MyRadio = bindable('radio',Radio);\n```\n\n好了，关于绑定就这些了。","filename":"markdowns/binding.md","root":"/Users/Houfeng/my/dev/mota","result":"<h1 id=\"%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A\">数据绑定</h1>\n<h3 id=\"%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\">基本用法</h3>\n<p>不要惊诧，就是「双向绑定」。Mota 不排斥「双向绑定」，使用 Mota 能够实现类似 <code>ng</code> 或 <code>vue</code> 的绑定效果。还是前边小节中的模型，我们来稍微改动一下组件的代码</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> model<span class=\"token punctuation\">,</span>binding <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'mota'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> User <span class=\"token keyword\">from</span> <span class=\"token string\">'./models/user'</span><span class=\"token punctuation\">;</span>\n\n@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span>User<span class=\"token punctuation\">)</span>\n@binding\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> fullName<span class=\"token punctuation\">,</span> firstName<span class=\"token punctuation\">,</span> popup <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>fullName<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>input data<span class=\"token operator\">-</span>bind<span class=\"token operator\">=</span><span class=\"token string\">\"firstName\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>popup<span class=\"token punctuation\">}</span><span class=\"token operator\">></span> click me <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App<span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> mountNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p><s>其中的「关键」就是 <code>@binding</code>，使用 <code>@binding</code> 后</s> (&gt;=1.2.0 的版本将会自动处理，不必显示的启用)，组件便具备了「双向绑定」的能力，在 <code>jsx</code> 中便可以通过名为 <code>data-bind</code> 的自定义 <code>attribute</code> 进行绑定了，<code>data-bind</code> 的值是一个「绑定表达式字符串」，绑定表达式执行的 <code>scope</code> 是 <code>model</code> 而不是 <code>this</code>，也就是只能与 <code>模型的成员</code> 进行绑定。</p>\n<p>会有一种情况是当要绑定的数据是一个循环变量时，「绑定表达式」写起会较麻烦也稍显长，比如</p>\n<pre><code class=\"language-js\">@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span>userModel<span class=\"token punctuation\">)</span>\n@binding\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> userList <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n     <span class=\"token punctuation\">{</span>userList<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user<span class=\"token punctuation\">,</span>index</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">(</span>\n       <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n         <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"checkobx\"</span> data<span class=\"token operator\">-</span>bind<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">userList[</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>index<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">].selected</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n         <span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span>\n       <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n     <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>因为「绑定表达式」的执行 <code>scope</code> 默认是 <code>this.model</code>，以及「表达式是个字符串」，看一下 <code>userList[${index}].selected</code> 这并不友好，为此 Mota 还提供了一个名为 <code>data-scope</code> 的 <code>attribute</code>，通过它能改变要绑定的 <code>scope</code>，参考如下示例</p>\n<pre><code class=\"language-js\">@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span>userModel<span class=\"token punctuation\">)</span>\n@binding\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> userList <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span>\n     <span class=\"token punctuation\">{</span>userList<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span><span class=\"token operator\">=></span><span class=\"token punctuation\">(</span>\n       <span class=\"token operator\">&lt;</span>li key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n         <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"checkobx\"</span> data<span class=\"token operator\">-</span>scope<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">}</span> data<span class=\"token operator\">-</span>bind<span class=\"token operator\">=</span><span class=\"token string\">\"selected\"</span><span class=\"token operator\">></span>\n         <span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span>\n       <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span>\n     <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过 <code>data-scope</code> 将 <code>input</code> 的绑定上下文对象声明为当前循环变量 <code>user</code>，这样就可以用 <code>data-bind</code> 直接绑定到对应 <code>user</code> 的属性上了。</p>\n<h3 id=\"%E5%8E%9F%E7%94%9F%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6\">原生表单控件</h3>\n<p>所有的原生表单控件，比如「普通 input、checkbox、radio、textarea、select」都可以直接进行绑定。其中，「普通 input 和 textrea」比较简单，将一个字符类型的模型数据与控件绑定就行了，而对于「checkbox 和 radio」 有多种不同的绑定形式。</p>\n<p>将「checkbox 或 radio」绑定到一个 <code>boolean</code> 值，此时会将 checkbox 或 radio 的 <code>checked</code> 属性和模型数据建立绑定，<code>checked</code> 反应了 <code>boolean</code> 变量的值，参考如下示例</p>\n<pre><code class=\"language-js\">@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> selected<span class=\"token punctuation\">:</span><span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n@binding\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"checkbox\"</span> data<span class=\"token operator\">-</span>bind<span class=\"token operator\">=</span><span class=\"token string\">\"selected\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"radio\"</span> data<span class=\"token operator\">-</span>bind<span class=\"token operator\">=</span><span class=\"token string\">\"selected\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如上示例通过 <code>this.model.selected</code> 就能拿到当前 checkbox 或 radio 的选中状态。</p>\n<p>将 checkbox 绑定到一个「数组」，通常是多个 checkbox 绑定同一个数组变量上，此时和数据建立绑定的是 checkbox 的 value，数据中会包含当前选中的 checkbox 的 value，如下</p>\n<pre><code class=\"language-js\">@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> selected<span class=\"token punctuation\">:</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n@binding\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"checkbox\"</span> data<span class=\"token operator\">-</span>bind<span class=\"token operator\">=</span><span class=\"token string\">\"selected\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"1\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"checkbox\"</span> data<span class=\"token operator\">-</span>bind<span class=\"token operator\">=</span><span class=\"token string\">\"selected\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"2\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>如上示例，通过 <code>this.selected</code> 就能知道当前有哪些 checkbox 被选中了，并拿到所有选中的 value</p>\n<p>将多个 radio 绑定我到一个「字符类型的变量」，此时和数据建立绑定的是 raido 的 value，因为 radio 是单选的，所以对应的数据是当前选中的 radio 的 value，如下</p>\n<pre><code class=\"language-js\">@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> selected<span class=\"token punctuation\">:</span><span class=\"token string\">''</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n@binding\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"radio\"</span> data<span class=\"token operator\">-</span>bind<span class=\"token operator\">=</span><span class=\"token string\">\"selected\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"1\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>input type<span class=\"token operator\">=</span><span class=\"token string\">\"radio\"</span> data<span class=\"token operator\">-</span>bind<span class=\"token operator\">=</span><span class=\"token string\">\"selected\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"2\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>通过 <code>this.model.selected</code> 就能拿到当前选中的 radio 的 <code>value</code></p>\n<h3 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6\">自定义组件</h3>\n<p>但是对于一些「组件库」中的「部分表单组件」不能直接绑定，因为 Mota 并没有什么依据可以判断这是一个什么组件。所以 Mota 提供了一个名为 <code>bindable</code> 的函数，用将任意组件包装成「可绑定组件」。</p>\n<p>bindable 有两种个参数，用于分别指定「原始组件」和「包装选项」</p>\n<pre><code class=\"language-js\"><span class=\"token comment\">//可以这样</span>\n<span class=\"token keyword\">const</span> MyComponent <span class=\"token operator\">=</span> <span class=\"token function\">bindable</span><span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">,</span> Component<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//也可这样</span>\n<span class=\"token keyword\">const</span> MyCompoent <span class=\"token operator\">=</span> <span class=\"token function\">bindable</span><span class=\"token punctuation\">(</span>Component<span class=\"token punctuation\">,</span> opts<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>关建是 <code>bindable</code> 需要的 <code>opts</code>，通过 <code>opts</code> 我们可以造诉 Mota 如何绑定这个组件，<code>opts</code> 中有两个重要的成员，它的结构如下</p>\n<pre><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'value 对应的属性名'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  event<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'value 改变的事件名'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>所以，我们可以这样包装一个自定义文本输入框</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> MyInput <span class=\"token operator\">=</span> <span class=\"token function\">bindable</span><span class=\"token punctuation\">(</span>Input<span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'value'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  event<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'onChange'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>对这种「value 不需要转换，<code>change</code> 能通过 <code>event</code> 或 <code>event.target.value</code> 拿到值」的组件，通过如上的代码就能完成包装了。</p>\n<p>对于有 <code>onChange</code> 和 <code>value</code> 的这类文本输入组件，因为 opts 的默认值就是</p>\n<pre><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  value<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'value'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  event<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'onChange'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>所以，可以更简单，这样就行，</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> MyInput <span class=\"token operator\">=</span> <span class=\"token function\">bindable</span><span class=\"token punctuation\">(</span>Input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>而对于 checkbox 和 radio 来讲，如上边讲到的它「根据不同的数据型有不同的绑定形式」，这就需要指定处理函数了，如下</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> radioOpts <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  prop<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'checked'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ctx<span class=\"token punctuation\">,</span> props</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> mValue <span class=\"token operator\">=</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> mValue <span class=\"token operator\">==</span> <span class=\"token string\">'boolean'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>mValue<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> mValue <span class=\"token operator\">==</span> props<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  event<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'onChange'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ctx<span class=\"token punctuation\">,</span> event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">,</span> checked <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> mValue <span class=\"token operator\">=</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> mValue <span class=\"token operator\">==</span> <span class=\"token string\">'boolean'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      ctx<span class=\"token punctuation\">.</span><span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>checked<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>checked<span class=\"token punctuation\">)</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>通过 <code>prop</code> 的第二个值，能指定「属性处理函数」，<code>event</code> 的第二个值能指取「事件处理函数」，处理函数的 <code>ctx</code> 是个特殊的对象</p>\n<ul>\n<li><code>ctx.getValue</code> 能获取「当前绑定的模型数据」</li>\n<li><code>ctx.setValue</code> 能设置「当前绑定的模型数据」</li>\n</ul>\n<p>上边是 <code>radio</code> 的配置，首先，在「属性处理函数」中通过绑定的「模型数据的类型」决定 <code>checked</code> 最终的状态是什么，并在函数中返回。再次，在「事件处理函数」中通过绑定的「模型数据的类型」决定将什么值回写到模型中。</p>\n<p>通过「属性处理函数」和「事件处理函数」几乎就能将任意的自定义组件转换为「可绑定组件」了。</p>\n<p>另外，对于常见的 <code>CheckBox</code> 和 <code>Radio</code> 类型的组件 Mota 也提供了内建的 <code>opts</code> 配置支持，如果一个自定义组件拥有和「原生 checkbox 一致的属性和事件模型」，那边可以直接用简单的方式去包装，如下</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">const</span> MyCheckBox <span class=\"token operator\">=</span> <span class=\"token function\">bindable</span><span class=\"token punctuation\">(</span><span class=\"token string\">'checkbox'</span><span class=\"token punctuation\">,</span>CheckBox<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> MyRadio <span class=\"token operator\">=</span> <span class=\"token function\">bindable</span><span class=\"token punctuation\">(</span><span class=\"token string\">'radio'</span><span class=\"token punctuation\">,</span>Radio<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>好了，关于绑定就这些了。</p>\n"},{"group":"guide","name":"use_model","title":"使用 Hook API","index":7,"source":"# 使用 Hook API\n\n### 简单介绍\n在 React 发布包含 `Hooks` 的 `alpah` 版后，Mota 也在 `next` 版本中新增支持了 Hook 风格的 API，随着 React `v16.8` 版本的发布带来了稳定版的 `Hooks` 支持。\n\n目前，Mota \b已经在稳定版中，提供了 `Hook API` 的支持，利用 React 的 `Hooks` 可以让你在不编写类的情况下使用 `state` 和 React 的其他功能。而使用 Mota 极少的 `Hook API` 将给应用带来 Hook 风格可响应的全局状态管理支持。\n\n### 基本用法\n\n```js\nimport React from 'react';\nimport { render } from 'react-dom';\n\nfunction App(){\n  //通过 useModel 拿到一个可响应的 model\n  const model = useModel({ count:0 });\n  //定义累加按钮事件\n  const onClick = useCallback(()=>model.count++);\n  //--\n  return <div>\n    <div>{model.count}</div>\n    <button onClick={onClick}>click me</button>\n  </div>;\n}\n\nrender(<App/>, document.getElementId('root'));\n```\n\n仅有一个新增 API `useModel`，通过 `useModel` 可在一个 `Function Component` 中使用 `model`，如同在 `Class Component` 中的 `@model`，此时的 `model` 依然是可响应的，执行时会对组件进行「依赖收集」，当操作 `model` 的成员时（比如 `model.count=1` 的赋值操作），Mota 会自动发现组件依赖的数据发生了变化并通知组件进行更新。\n\n### 进阶说明\n\n在基本用法中提到了一个关键词「依赖收集」，通过 `useModel` 拿到了可响应的 `model`，默认情况下只有被组件依赖的模型数据发生了变化组件才会更新，比如下边的示例代码中，只有在 `model.a` 发生变化时，组件才会重新渲染。\n\n\n```js\nfunction Demo(){\n  const model = useModel({ a:0, b:1 });\n  ...\n  return <div>{model.a}</div>\n}\n```\n\n实际开发过程中有时「组件依赖了模型上的某个对象，但希望这个对象的子成员发生变化时，组件也要重新渲染」\n\n```js\nfunction Demo(){\n  const { info } = useModel({ info: { name: 'test'} });\n  ...\n  return <Info data={info}/>\n}\n```\n\n因为对于 `Demo` 来说只依赖了 `info`，而 `info` 的引用是一直没有变化的，所以在 `info.name` 发生变化时 `Demo` 并不会重新渲染。那这样 `Info` 组件会一直显示旧的数据。\n\n如何处理这个问题？\n\n一个方法是让 `Info` 也通过 `useModel` 有自已的 `model`，那 `Info` 的依赖会被独立解析，比如\n\n```js\nfunction Info(props){\n  const info = useModel(props.data);\n  return <div>{info.name}</div>\n}\n```\n\n这个虽然 `Demo` 不会重新渲染，但 Mota 会发现 `Info` 依赖了 `info.name`，但发现数据变化时，`Info` 会自动更新。\n\n还有一个方法是，在更新 `info.name` 时换一个写法\n\n```js\n//通常的直接给 name 赋值\nmodel.info.name = 'test';\n//如下的给 info 赋值的写法，会让 Demo 发现 info 的变化\nmodel.info = {...model.info, name: 'test'};\n```\n\n除了上述的两个方法，还有一个方法就是通过 `useModel` 的第二个参数显示的声明额外的依赖，第二个参数可是一个数组，数组中是显式声明的依赖，格式为子成员的路径，如下\n\n```js\nfunction Demo(){\n  const { info } = useModel({ \n    info: { name: 'test'} \n  }, ['info.name']);\n  ...\n  return <Info data={info}/>\n}\n```\n\n但有时时模型数据是一个数组，我们无法直接指定每个子元素的路径，这时第二个参数还可以是一个函数，函数的参数是「变化的模型数据的路径」，可参函数中返回 `boolean` 值决定是否需要更新组件，如下\n\n```js\nfunction Demo(){\n  const { info } = useModel({ \n    info: [{name: 'test1'}] \n  }, p=> p.endsWith('.name'));\n  ...\n  return <Info data={info}/>\n}\n```\n\n示例中通过用 `endsWith` 路径是不是 `*.name` 结尾的决定要不要更新，当然也可以用更多的判断方法决定要不要更新。","filename":"markdowns/use_model.md","root":"/Users/Houfeng/my/dev/mota","result":"<h1 id=\"%E4%BD%BF%E7%94%A8-hook-api\">使用 Hook API</h1>\n<h3 id=\"%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D\">简单介绍</h3>\n<p>在 React 发布包含 <code>Hooks</code> 的 <code>alpah</code> 版后，Mota 也在 <code>next</code> 版本中新增支持了 Hook 风格的 API，随着 React <code>v16.8</code> 版本的发布带来了稳定版的 <code>Hooks</code> 支持。</p>\n<p>目前，Mota \b已经在稳定版中，提供了 <code>Hook API</code> 的支持，利用 React 的 <code>Hooks</code> 可以让你在不编写类的情况下使用 <code>state</code> 和 React 的其他功能。而使用 Mota 极少的 <code>Hook API</code> 将给应用带来 Hook 风格可响应的全局状态管理支持。</p>\n<h3 id=\"%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\">基本用法</h3>\n<pre><code class=\"language-js\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> render <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//通过 useModel 拿到一个可响应的 model</span>\n  <span class=\"token keyword\">const</span> model <span class=\"token operator\">=</span> <span class=\"token function\">useModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> count<span class=\"token punctuation\">:</span><span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//定义累加按钮事件</span>\n  <span class=\"token keyword\">const</span> onClick <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span>model<span class=\"token punctuation\">.</span>count<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">//--</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>model<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>onClick<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>click me<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App<span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementId</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>仅有一个新增 API <code>useModel</code>，通过 <code>useModel</code> 可在一个 <code>Function Component</code> 中使用 <code>model</code>，如同在 <code>Class Component</code> 中的 <code>@model</code>，此时的 <code>model</code> 依然是可响应的，执行时会对组件进行「依赖收集」，当操作 <code>model</code> 的成员时（比如 <code>model.count=1</code> 的赋值操作），Mota 会自动发现组件依赖的数据发生了变化并通知组件进行更新。</p>\n<h3 id=\"%E8%BF%9B%E9%98%B6%E8%AF%B4%E6%98%8E\">进阶说明</h3>\n<p>在基本用法中提到了一个关键词「依赖收集」，通过 <code>useModel</code> 拿到了可响应的 <code>model</code>，默认情况下只有被组件依赖的模型数据发生了变化组件才会更新，比如下边的示例代码中，只有在 <code>model.a</code> 发生变化时，组件才会重新渲染。</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> model <span class=\"token operator\">=</span> <span class=\"token function\">useModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> a<span class=\"token punctuation\">:</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span><span class=\"token number\">1</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>model<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>实际开发过程中有时「组件依赖了模型上的某个对象，但希望这个对象的子成员发生变化时，组件也要重新渲染」</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> info <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> info<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'test'</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>Info data<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>info<span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>因为对于 <code>Demo</code> 来说只依赖了 <code>info</code>，而 <code>info</code> 的引用是一直没有变化的，所以在 <code>info.name</code> 发生变化时 <code>Demo</code> 并不会重新渲染。那这样 <code>Info</code> 组件会一直显示旧的数据。</p>\n<p>如何处理这个问题？</p>\n<p>一个方法是让 <code>Info</code> 也通过 <code>useModel</code> 有自已的 <code>model</code>，那 <code>Info</code> 的依赖会被独立解析，比如</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Info</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> info <span class=\"token operator\">=</span> <span class=\"token function\">useModel</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>info<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这个虽然 <code>Demo</code> 不会重新渲染，但 Mota 会发现 <code>Info</code> 依赖了 <code>info.name</code>，但发现数据变化时，<code>Info</code> 会自动更新。</p>\n<p>还有一个方法是，在更新 <code>info.name</code> 时换一个写法</p>\n<pre><code class=\"language-js\"><span class=\"token comment\">//通常的直接给 name 赋值</span>\nmodel<span class=\"token punctuation\">.</span>info<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'test'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//如下的给 info 赋值的写法，会让 Demo 发现 info 的变化</span>\nmodel<span class=\"token punctuation\">.</span>info <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>model<span class=\"token punctuation\">.</span>info<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'test'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>除了上述的两个方法，还有一个方法就是通过 <code>useModel</code> 的第二个参数显示的声明额外的依赖，第二个参数可是一个数组，数组中是显式声明的依赖，格式为子成员的路径，如下</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> info <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> \n    info<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">'test'</span><span class=\"token punctuation\">}</span> \n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'info.name'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>Info data<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>info<span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>但有时时模型数据是一个数组，我们无法直接指定每个子元素的路径，这时第二个参数还可以是一个函数，函数的参数是「变化的模型数据的路径」，可参函数中返回 <code>boolean</code> 值决定是否需要更新组件，如下</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Demo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> info <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> \n    info<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">:</span> <span class=\"token string\">'test1'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span> \n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">p</span><span class=\"token operator\">=></span> p<span class=\"token punctuation\">.</span><span class=\"token function\">endsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>Info data<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>info<span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>示例中通过用 <code>endsWith</code> 路径是不是 <code>*.name</code> 结尾的决定要不要更新，当然也可以用更多的判断方法决定要不要更新。</p>\n"},{"group":"guide","name":"hook_model","title":"面向 Hook 的模型","index":8,"source":"# 面向 Hook 的模型\n\n### 一些说明\n\n针对 Mota 的 `useModel` 的模型本质上和针对 `@model` 的模型并无本质区别，用以往的风格编写的「模型类」或「单例的普通 Object」，除了能用于 `@model` 也是能用于 `useModel` 的。\n\n既然用了 `Hook API`，是不是可在编写模型也避免再写「类」或「单例的 Object」？为此 `useModel` 还提供了用 `ES Module` 作为模型的支持，如用其他风格的模型一样，`ES Module` 风格的模型也不需要引用额外的依赖，仅用 `ES` 原生语法即可。\n\n### 用 ES Module 编写模型\n\n通过 `ES Module` 直接作为 `model` 的优点时「简单、直接」，同时由于为了保证「可响应」不被破坏，需要一点点约束，就是「必须导出一个 state 对象」，如下\n\n```js\nexport const state = {\n  name: 'test'\n}\n\nexport function setName(name){\n  state.name = name\n}\n```\n\n上边的代码是一个最简单的可当作 `model` 的 `ES Module`，一个包含「state 和一组件函数」的 `ES Module` 就是一个可被 `useModel` 使用的 `model`，参考如下代码\n\n```js\nimport * as demo from './models/demo';\n\nfunction App(){\n  const { name } = useModel(demo);\n  return <div>{name}</div>;\n}\n```\n\n注意：必须 export 一个 state 的约束只针对于 `ES Module`，用 `class` 或 `object` 的风格编写的 `model` 无任何约束。","filename":"markdowns/hook_model.md","root":"/Users/Houfeng/my/dev/mota","result":"<h1 id=\"%E9%9D%A2%E5%90%91-hook-%E7%9A%84%E6%A8%A1%E5%9E%8B\">面向 Hook 的模型</h1>\n<h3 id=\"%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E\">一些说明</h3>\n<p>针对 Mota 的 <code>useModel</code> 的模型本质上和针对 <code>@model</code> 的模型并无本质区别，用以往的风格编写的「模型类」或「单例的普通 Object」，除了能用于 <code>@model</code> 也是能用于 <code>useModel</code> 的。</p>\n<p>既然用了 <code>Hook API</code>，是不是可在编写模型也避免再写「类」或「单例的 Object」？为此 <code>useModel</code> 还提供了用 <code>ES Module</code> 作为模型的支持，如用其他风格的模型一样，<code>ES Module</code> 风格的模型也不需要引用额外的依赖，仅用 <code>ES</code> 原生语法即可。</p>\n<h3 id=\"%E7%94%A8-es-module-%E7%BC%96%E5%86%99%E6%A8%A1%E5%9E%8B\">用 ES Module 编写模型</h3>\n<p>通过 <code>ES Module</code> 直接作为 <code>model</code> 的优点时「简单、直接」，同时由于为了保证「可响应」不被破坏，需要一点点约束，就是「必须导出一个 state 对象」，如下</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'test'</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  state<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>上边的代码是一个最简单的可当作 <code>model</code> 的 <code>ES Module</code>，一个包含「state 和一组件函数」的 <code>ES Module</code> 就是一个可被 <code>useModel</code> 使用的 <code>model</code>，参考如下代码</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> demo <span class=\"token keyword\">from</span> <span class=\"token string\">'./models/demo'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> name <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useModel</span><span class=\"token punctuation\">(</span>demo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>注意：必须 export 一个 state 的约束只针对于 <code>ES Module</code>，用 <code>class</code> 或 <code>object</code> 的风格编写的 <code>model</code> 无任何约束。</p>\n"},{"group":"guide","name":"typescript","title":"在 TS 中使用","index":8,"source":"# 在 TS 中使用 Mota\n\nMota 的 `Package` 中自带了「类型定义文件」，无论使用 `Class + Decorator` 风格的 API 或使用 `Hooks` 风格的 API，都能愉快的使用 TypeScript，下边有两个小提示。\n\n### 提示一：使用 @model \n\n在通过 `@model` 为组件关联了一个 `model` 后，需要声明 `this.model` 的类型，参考如下代码\n\n```js\nimport * as React from \"react\";\nimport { model, watch, mapping } from \"mota\";\nimport { DemoModel } from \"./DemoModel\";\n\n@model(DemoModel)\nexport class Demo extends React.Component {\n\n  //需要声明 model 的类型\n  model: DemoModel;\n\n  render() {\n    //便能让 this.model 具备完整的类型提示了\n    const { name } = this.model;\n    return <div className=\"demo\">  \n      {name}  \n    </div>;\n  }\n}\n```\n\n### 提示一：使用 useModel\n\n完整的 `useModel` 的定义为 `useModel<T>(model:T)=>T`，但使用 `useModel` 时一般不需做特别的声明，默认情况下 `TS` 就能完成类型推导\n\n```js\nimport * as React from \"react\";\nimport { useModel } from \"mota\";\nimport { DemoModel } from \"./DemoModel\";\n\nexport function Demo {\n  const { name } = useModel(DemoModel);\n  return <div className=\"demo\">  \n    {name}  \n  </div>;\n}\n```","filename":"markdowns/typescript.md","root":"/Users/Houfeng/my/dev/mota","result":"<h1 id=\"%E5%9C%A8-ts-%E4%B8%AD%E4%BD%BF%E7%94%A8-mota\">在 TS 中使用 Mota</h1>\n<p>Mota 的 <code>Package</code> 中自带了「类型定义文件」，无论使用 <code>Class + Decorator</code> 风格的 API 或使用 <code>Hooks</code> 风格的 API，都能愉快的使用 TypeScript，下边有两个小提示。</p>\n<h3 id=\"%E6%8F%90%E7%A4%BA%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8-%40model\">提示一：使用 @model</h3>\n<p>在通过 <code>@model</code> 为组件关联了一个 <code>model</code> 后，需要声明 <code>this.model</code> 的类型，参考如下代码</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> model<span class=\"token punctuation\">,</span> watch<span class=\"token punctuation\">,</span> mapping <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"mota\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> DemoModel <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./DemoModel\"</span><span class=\"token punctuation\">;</span>\n\n@<span class=\"token function\">model</span><span class=\"token punctuation\">(</span>DemoModel<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Demo</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">//需要声明 model 的类型</span>\n  model<span class=\"token punctuation\">:</span> DemoModel<span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//便能让 this.model 具备完整的类型提示了</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> name <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"demo\"</span><span class=\"token operator\">></span>  \n      <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span>  \n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"%E6%8F%90%E7%A4%BA%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8-usemodel\">提示一：使用 useModel</h3>\n<p>完整的 <code>useModel</code> 的定义为 <code>useModel&lt;T&gt;(model:T)=&gt;T</code>，但使用 <code>useModel</code> 时一般不需做特别的声明，默认情况下 <code>TS</code> 就能完成类型推导</p>\n<pre><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useModel <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"mota\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> DemoModel <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./DemoModel\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> Demo <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> name <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useModel</span><span class=\"token punctuation\">(</span>DemoModel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"demo\"</span><span class=\"token operator\">></span>  \n    <span class=\"token punctuation\">{</span>name<span class=\"token punctuation\">}</span>  \n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"}]}],"links":[{"text":"状态管理 (Mota)","url":"//houfeng.net/mota/"},{"text":"数据验证 (Validation)","url":"//houfeng.net/mota-validation/"},{"text":"表单组件 (Form)","url":"//houfeng.net/mota-form/"},{"text":"源码 (GitHub)","url":"//github.com/Houfeng/mota"}]}],"plugins":[{"name":"doczilla-place","options":{}},{"name":"doczilla-include","options":{}},{"name":"doczilla-container","options":{}},{"name":"doczilla-highlight","options":{}},{"name":"doczilla-details","options":{}},{"name":"doczilla-card","options":{}},{"name":"doczilla-anchor","options":{}}],"mode":"static","baseUri":"","extname":".html"};